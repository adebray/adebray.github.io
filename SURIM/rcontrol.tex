\subsection{Lists, Arrays, Vectors, and Matrices}
A list is the R equivalent to a dictionary (in Python and such). It contains keys and values (e.g. \texttt{list(2,5,"bar="baz")}), though if you leave out a value, it apparently just assigns a hash code. It is really general: one can make a list of anything to anything else, and different types of objects can go into the same list. The notation for retrieving an element of a list is \texttt{name[[5]]}. Lists are particularly useful because they allow you to return several pieces of data from a single function.

A vector is a related data structure that is limited to one data type. It is generated by using the function \texttt{c()} instead of \texttt{list()}. Interestingly, R views numbers not as constants, but as numeric vectors of length 1.\footnote{This can't be completey literally true, or it would cause a very interesting sort of depth-of-recursion error, but it's nonetheless an interesting insight into how R processes data.}

An array is a multidimensional vector. A matrix is a special case (dimension 2), but a vector is not (a 1-dimensional array has a couple technical differences, such as calling \texttt{length()} for vectors and \texttt{dim()} for arrays, but conceptually, they are the same).
\subsection{Loops}
One preliminary is that the query command \texttt{?} doesn't work for \texttt{for}. Instead, one should use \texttt{?Control}, which will provide help and/or information on several control structures. 

Syntax of the \texttt{for} loop is unsurprising: one can iterate through a vector \texttt{Victor} with the syntax \texttt{for(q in Victor)} (with the contents of the loop in braces, as in C, C++, and Java). One can also use range syntax, such as \texttt{for(i in 1:10)}, and thus access elements of a vector by index. An alternate syntax is \texttt{seq(10)}.

One can also break loops with \texttt{break}, as in other languages. One also has the \texttt{next} command, which jumps to the end of this iteration of a given \texttt{for} loop without executing the rest of the loop.

A \texttt{while} loop is similar, but waits for a condition to happen rather than actually incrementing something. The example given is of a binary search, which was kind of cool: specifically, the condition is \texttt{while(lo <= hi)} (where \texttt{lo} and \texttt{hi} are the lower and upper bounds on the index, respectively).

R has the interesting quirk that \texttt{for} and \texttt{while} loops are actually not very good things to use. As the problem increases in size and complexity, using these loops can be much slower. Many R functions are implemented in lower-level languages such as C and FORTRAN. This makes it easier to use, but it also makes R slower. It takes time for R to make calls to and from C, and so if such a call is made within a loop, it will take a lot of time. For this reason it is generally faster (and therefore preferable) to make calls to an \texttt{apply} function.
\subsection{\texttt{apply}}
There are three \texttt{apply} functions, \texttt{lapply}, \texttt{sapply}, and \texttt{tapply}. Two of these are wrappers built on the third. These take a vector, apply a given function to each element, and returns the result as a list.

The primary difference between \texttt{lapply} and \texttt{sapply} is that the latter attempts to turn the output into a vector or a matrix. For example, if the function returns an array or vector, it can turn this into a matrix. The vector is also useful because it is a map of the input to the output values. It can also be useful in the simpler case where another argument requires a vector instead of a list.

\texttt{apply} functions are useful in that they demonstrate vectorization: as the size of the problem increases, the number of calls to R functions is constant. Though the complexity of the problem isn't necessarily constant, it's easier to only make one call to a lower-level language. This is why these commands are generally faster than \texttt{for} and \texttt{while} loops. In order to determine how slow or fast such a command takes, one has the function \texttt{system.time()}.

Other vectorized functions exist, such as \texttt{rowsum()} for obtaining the total sum of a row of a matrix.

Higher-dimensional problems can cause something related to vectorization, but not completely identical.

\texttt{tapply} takes a vector and a set of labels of the entries in the vector and catches all the elements of the vector with a certain label. For example, the multiplication of large sparse matrices can be accomplished by ignoring all the zeroes. This can change a problem from requiring an impossible amount of communication to being relatively trivial.
